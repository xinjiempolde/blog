---
title: 从百草园到三味书屋
date: 2023-06-13 20:07:32
tags:
categories:
    - others
---

# 0x00 引言

最近看论文看到使用SIMD指令加速，从指令集到AT&T汇编再到linux系统调用一路折腾，这里就做一个小小的记录。

<!--more-->

# 0x01 System call和System interrupt

简单来说，这两者均是为了用户态调用内核态的功能（比如文件读写等）。

## 使用C语言进行syscall

> 参考[https://www.baeldung.com/cs/system-call-vs-system-interrupt](https://www.baeldung.com/cs/system-call-vs-system-interrupt)

```c
#include <sys/syscall.h>
int main() {
	syscall(SYS_write, 1, "hello world\n", 12);
	return 0;
}
```

先来看看头文件的内容，<sys/syscall.h>文件在`/usr/include/x86_64-linux-gnu/sys/syscall.h`下，内如如下：

```c
#ifndef _SYSCALL_H
#define _SYSCALL_H      1

/* This file should list the numbers of the system calls the system knows.
   But instead of duplicating this we use the information available
   from the kernel sources.  */
#include <asm/unistd.h>

/* The Linux kernel header file defines macros __NR_*, but some
   programs expect the traditional form SYS_*.  <bits/syscall.h>
   defines SYS_* macros for __NR_* macros of known names.  */
#include <bits/syscall.h>

#endif
```

再来看看<bits/syscall.h>中的内容，`vim /usr/include/x86_64-linux-gnu/bits/syscall.h`:

```c
#ifdef __NR_waitid
# define SYS_waitid __NR_waitid
#endif

#ifdef __NR_waitpid
# define SYS_waitpid __NR_waitpid
#endif

#ifdef __NR_write
# define SYS_write __NR_write
#endif

#ifdef __NR_writev
# define SYS_writev __NR_writev
#endif
```

可以看到`SYS_write`就是`__NR_write`

再来看看`<asm/unistd.h>`中的内容，`vim /usr/include/x86_64-linux-gnu/asm/unistd.h`

```c
#ifndef _ASM_X86_UNISTD_H
#define _ASM_X86_UNISTD_H

/*
 * x32 syscall flag bit.  Some user programs expect syscall NR macros
 * and __X32_SYSCALL_BIT to have type int, even though syscall numbers
 * are, for practical purposes, unsigned long.
 *
 * Fortunately, expressions like (nr & ~__X32_SYSCALL_BIT) do the right
 * thing regardless.
 */
#define __X32_SYSCALL_BIT       0x40000000

# ifdef __i386__
#  include <asm/unistd_32.h>
# elif defined(__ILP32__)
#  include <asm/unistd_x32.h>
# else
#  include <asm/unistd_64.h>
# endif

#endif /* _ASM_X86_UNISTD_H */

```

找到了我们最后想要的`<asm/unistd_64.h>`，`vim /usr/include/x86_64-linux-gnu/asm/unistd_64.h`

```c
#ifndef _ASM_X86_UNISTD_64_H
#define _ASM_X86_UNISTD_64_H 1

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
#define __NR_stat 4
#define __NR_fstat 5
#define __NR_lstat 6
#define __NR_poll 7
#define __NR_lseek 8
#define __NR_mmap 9
#define __NR_mprotect 10
#define __NR_munmap 11
#define __NR_brk 12
#define __NR_rt_sigaction 13
#define __NR_rt_sigprocmask 14
#define __NR_rt_sigreturn 15
#define __NR_ioctl 16
#define __NR_pread64 17
#define __NR_pwrite64 18
#define __NR_readv 19
#define __NR_writev 20
...
#define __NR_exit 60
```

下面用一张图简单梳理一下：

![syscall.h](http://img.singhe.art/syscall.h.png)

回到最开始的程序

```c
#include <sys/syscall.h>
int main() {
	syscall(SYS_write, 1, "hello world\n", 12);
	return 0;
}
```

syscall的原型为`long syscall(long number, ...);`，通过SYS_write调用sys_write，其函数原型为`long sys_write(unsigned int fd, const char __user *buf, size_t count);`

其作用就是通过syscall调用sys_write()功能，并写入stdout(1)中，stdin为0，stderr为2，内容为"hello world\n"，长度为12.



## 使用汇编进行syscall

> 参考[https://blog.csdn.net/chuck_huang/article/details/79922595](https://blog.csdn.net/chuck_huang/article/details/79922595)
>
> [AMD64 ABI convention](https://web.archive.org/web/20160801075139/http://www.x86-64.org/documentation/abi.pdf)

![ABI_reg_usage](http://img.singhe.art/20180413032340186)

![enter image description here](https://i.stack.imgur.com/j8hpC.png)

System V ABI规定了对64位程序的接口，也规定了函数参数的传递规则，根据此规则，用调用sys_write(这里参数的第一第二的顺序是针对sys_write而言的，syscall要调用哪一个函数由rax决定，由#define __NR_write 1知道要调用sys_write应该将rax设置为1)，所以文件描述符1需要加载到rdi寄存器，“hello world\n” 字符串的地址需要加载到 %rsi，字符串的长度加载到 rdx。

那么我们的AT&T汇编程序`hello.s`如下：

```assembly
    .section .data
message:
    .ascii "hello world!\n"
    length = . - message

    .section .text
    .global _start      # must be declared for linker
_start:
    movq $1, %rax      # 'write' syscall number
    movq $1, %rdi      # file descriptor, stdout
    lea message(%rip), %rsi # relative addressing string message 
    movq $length, %rdx
    syscall

    movq $60, %rax     # 'exit' syscall number
    xor %rdi, %rdi      # set rdi to zero, first parameter of sys_exit
    syscall

```

其中 .section .data 和 .section .text 定义个数据段 和代码段。

message 只是一个label 方便我们来引用 hello world 字符串。

length = . - message 用来计算字符串的长度。. 用来表示当前的地址

_start 是程序的入口

进行汇编和链接，并运行：

```shell
singheart@amd:~/project/assembly$ as -o hello.o hello.s
singheart@amd:~/project/assembly$ ld -o hello hello.o
singheart@amd:~/project/assembly$ ./hello 
hello world!
singheart@amd:~/project/assembly$ 

```



## 使用汇编进行interrupt

```assembly
#hello.s
.data                                # 数据段声明
    msg : .string "hello,world!\n"    # 要输出的字符串
    len = . - msg                    # 字串长度
.text                                # 代码段声明
.global _start                        # 指定入口函数

_start:                                # 在屏幕上显示一个字符串
    movl $len, %edx                    # 参数三：字符串长度
    movl $msg, %ecx                    # 参数二：要显示的字符串
    movl $1, %ebx                    # 参数一：文件描述符(stdout)
    movl $4, %eax                    # 系统调用号(sys_write)
    int $0x80                        # 调用内核功能    
                                    # 退出程序
    movl $0, %ebx                    # 参数一：退出代码
    movl $1, %eax                    # 系统调用号(sys_exit)
    int $0x80                        # 调用内核功能
#end
```

这里使用int $0x80中断，不太了解详细信息，不做过多解释。



## 使用汇编进行printf

```assembly
.section .data
msg:
    .asciz "Printf In Assembly!!\n"

.section .text
.globl main
main:
    leaq msg(%rip), %rdi
    xor %al, %al
    call printf

    xor %edi, %edi
    call exit
```

还是根据AMD64 ABI convention，传递函数参数并进行函数调用

```shell
singheart@amd:~/project/assembly$ gcc -o print print.s 
singheart@amd:~/project/assembly$ ./print 
Printf In Assembly!!
```

