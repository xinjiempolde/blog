---
title: 丢失修改、不可重复度、读脏数据
date: 2022-05-31 18:41:25
tags:
    - database
    - lock
categories:
    - database
---

# 背景

数据库并发如果不做任何的控制，会破坏事务ACID特性的隔离性和一致性，如丢失修改、不可重复读、幻影现象和读“脏数据”等问题。

<!--more-->

# 问题解释

本章介绍丢失修改、不可重复读和读“脏数据”的概念。

## 丢失修改

![image-20220714104421583](http://img.singhe.art/%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png)

两个事务T~1~和T~2~读入同一数据并修改，T~2~提交的结果破坏了T~1~提交的结果，导致T~1~的修改被丢失。



## 不可重复读

![image-20220715091255981](http://img.singhe.art/image-20220715091255981.png)

事务T~1~读取某一数据后，事务T~2~对其进行了修改，当事务T~1~再次读区该数据时，得到与前一次不一样的结果。



## 幻影现象

事务T~1~从数据库读取某些记录后，事务T~2~删除(或者插入了)部分记录，事务T~1~再按照相同条件读取的时候发现某些记录消失了(或新增了)。



##  读“脏数据”

![image-20220715091933540](http://img.singhe.art/image-20220715091933540.png)

读“脏数据”是指事务T~1~修改某一数据并将其写会磁盘，事务T~2~读区同一数据后，T~1~由于某种原因被撤销，这时被T~1~修改过的数据恢复原值，T~2~读到的数据就与数据库中的数据不一致，则T~2~读到的数据就为“脏”数据，即不正确的数据。



# 问题解决

并发控制的技术有很多，比如封锁、时间戳、乐观控制和多版本并发控制，这里介绍封锁的方法。

## 封锁的相容矩阵

![image-20220715093307688](http://img.singhe.art/image-20220715093307688.png)



## 封锁协议

在运用X锁和S锁时，还需要约定一些规则。例如，合适申请X锁或S锁、持锁时间、何时释放等。这些规则被称为封锁协议。

### 一级封锁协议(读未提交)

一级封锁协议是指，事务T在修改数据R之前必须对其加X锁，知道事务结束才释放。

在一级封锁协议中，如果仅仅是读数据而不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏数据”，它只能够解决丢失修改的问题。



### 二级封锁协议(读已提交)

二级封锁协议在一级封锁协议的基础上增加事务T在读取数据R之前必须对其加S锁，读完后即可释放S锁。

二级封锁协议能够解决丢失修改、读“脏数据”的问题，不能解决可重复读



### 三级封锁协议(可重复读)

三级封锁协议是指，在一级封锁协议的基础上增加事务T在读取R之前必须对其加S锁，直到事务结束才释放。三级封锁协议和二级封锁协议的差别在于读锁的持续时间不同。

三级封锁协议能够解决丢失修改、读“脏数据”、不可重复读的问题。但是不能解决幻读的问题，因为封锁都是对某一行进行加锁，而幻读出现问题的地方是整个表格。



### 可串形化

能够解决所有的问题，但是并发性能太差。
